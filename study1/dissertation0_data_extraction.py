# -*- coding: utf-8 -*-
"""dissertation0_data extraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13UFit4ZaAuy8DBZNkW3ZMP-eSGdI-Rct
"""

!pip install --q spacy

import spacy
from spacy import displacy

# 임시로 spaCy 모델 로드 (stanza 결과 직접 연결은 복잡하므로 대체)
nlp = spacy.load("en_core_web_sm")

# 문장 파싱
doc = nlp("A bran muffin I can give you.")

# 의존 구문 시각화
displacy.render(doc, style="dep", jupyter=True)

# ✅ Step 1: stanza 설치 (처음 1회만 실행)
!pip install stanza --quiet

# ✅ Step 2: stanza 다운로드 및 초기화
import stanza

# 영어 모델 다운로드 (처음 1회만 실행)
stanza.download('en')

# NLP 파이프라인 로드
nlp = stanza.Pipeline('en')

# ✅ Step 3: 테스트 문장 입력
text = "A bran muffin I can give you."

# 문장 분석
doc = nlp(text)

# ✅ Step 4: CoNLL-U 형식 출력
for sentence in doc.sentences:
    print("# text =", sentence.text)
    for word in sentence.words:
        print(f"{word.id}\t{word.text}\t{word.lemma}\t{word.upos}\t{word.xpos}\t{word.feats if word.feats else '_'}\t{word.head}\t{word.deprel}\t_\t_")
    print()

###문장추출###

# 파일을 라인 단위로 읽어서 리스트에 저장
with open("bnc_filtered.txt", "r", encoding="utf-8") as f:
    data = [line.strip() for line in f if line.strip()]  # 공백 줄은 제외하고 저장

def is_preposing(sent):
    for word in sent.words:
        if word.deprel == "root" and word.upos in {"NOUN", "PROPN", "PRON"}:
            root_noun = word.text
            root_noun_id = word.id
            for w in sent.words:
                if w.deprel == "acl:relcl" and w.upos == "VERB" and w.head == root_noun_id:
                    return True, root_noun
    return False, None

def is_passive(sent):
    root_verb_id = None
    has_be_auxpass = False
    by_agent_ok = False
    passive_subject = None

    for word in sent.words:
        if word.deprel == "root" and word.upos == "VERB":
            root_verb_id = word.id
            break
    if root_verb_id is None:
        return False, None

    for word in sent.words:
        if word.lemma == "be" and word.deprel == "aux:pass" and word.head == root_verb_id:
            has_be_auxpass = True
            break
    if not has_be_auxpass:
        return False, None

    for word in sent.words:
        if word.text.lower() == "by":
            head_id = word.head
            for candidate in sent.words:
                if candidate.id == head_id and candidate.upos in {"NOUN", "PROPN", "PRON"}:
                    by_agent_ok = True
                    break

    for word in sent.words:
        if word.deprel == "nsubj:pass" and word.upos in {"NOUN", "PROPN", "PRON"}:
            passive_subject = word.text

    return has_be_auxpass and by_agent_ok and passive_subject is not None, passive_subject

def is_inversion_type1(sent):
    first = sent.words[0]
    if first.deprel not in {"advmod", "case", "csubj"}:
        return False, None

    # 콤마 확인: root 이전에 쉼표가 있는지 확인
    root_idx = -1
    for i, word in enumerate(sent.words):
        if word.deprel == "root":
            root_idx = i
            break

    if root_idx == -1:
        return False, None

    for i in range(root_idx):
        if sent.words[i].text == ",":
            return False, None

    root = sent.words[root_idx]
    if root.upos not in {"NOUN", "PROPN", "PRON"}:
        return False, None

    has_cop = False
    candidates = []

    for word in sent.words:
        if word.deprel == "cop" and word.head == root.id:
            has_cop = True
        if word.upos in {"NOUN", "PROPN", "PRON"}:
            if word.head == root.id:
                candidates.append(word.text)
            else:
                for mid in sent.words:
                    if mid.id == word.head and mid.deprel in {"advmod", "csubj"} and mid.head == root.id:
                        candidates.append(word.text)
                        break

    return has_cop and len(candidates) > 0, ", ".join(candidates)


def is_inversion_type2(sent):
    first = sent.words[0]
    if first.deprel not in {"advmod", "case", "csubj"}:
        return False, None

    root_idx = -1
    for i, word in enumerate(sent.words):
        if word.deprel == "root":
            root_idx = i
            break

    if root_idx == -1:
        return False, None

    for i in range(root_idx):
        if sent.words[i].text == ",":
            return False, None

    root = sent.words[root_idx]
    if root.upos != "VERB":
        return False, None

    has_obj_or_obl = False
    candidates = []

    for word in sent.words:
        if word.deprel in {"obj", "obl"} and word.upos in {"NOUN", "PROPN", "PRON"}:
            has_obj_or_obl = True

        if word.upos in {"NOUN", "PROPN", "PRON"}:
            if word.head == root.id:
                candidates.append(word.text)
            else:
                for mid in sent.words:
                    if mid.id == word.head and mid.deprel in {"advmod", "csubj"} and mid.head == root.id:
                        candidates.append(word.text)
                        break

    return has_obj_or_obl and len(candidates) > 0, ", ".join(candidates)



def is_inversion(sent):
    match1, noun1 = is_inversion_type1(sent)
    match2, noun2 = is_inversion_type2(sent)

    if match1:
        return True, noun1
    elif match2:
        return True, noun2
    return False, None

from google.colab import drive
drive.mount('/content/drive')

save_dir = "/content/drive/MyDrive/IS_results"

import os
os.makedirs(save_dir, exist_ok=True)  # 폴더 없으면 생성

import stanza
from tqdm import tqdm
import csv

# stanza 초기화 (처음 1회)
nlp = stanza.Pipeline(
    'en',
    use_gpu=True,
    processors='tokenize,mwt,pos,lemma,depparse',
    tokenize_batch_size=64,
    pos_batch_size=64,
    depparse_batch_size=64
)

print(len(data))

df = data[600001:] #처음부터 다시

preposing = []
passive = []
inversion = []

import pickle
from tqdm import tqdm

start_index = 0

for i in tqdm(range(start_index, len(df)), desc="검사 중"):
    text = df[i]

    try:
        doc = nlp(text)

        for sent in doc.sentences:
            match, noun = is_preposing(sent)
            if match:
                preposing.append([text, noun])

            match, noun = is_inversion(sent)
            if match:
                inversion.append([text, noun])

            if "by" in text.lower():
                match, noun = is_passive(sent)
                if match:
                    passive.append([text, noun])

    except Exception as e:
        print(f"{i}번째 문장에서 오류 발생: {e}")
        continue

    if i % 100 == 0:
        with open(f"{save_dir}/preposing.pkl", "wb") as f:
            pickle.dump(preposing, f)
        with open(f"{save_dir}/inversion.pkl", "wb") as f:
            pickle.dump(inversion, f)
        with open(f"{save_dir}/passive.pkl", "wb") as f:
            pickle.dump(passive, f)
        with open(f"{save_dir}/checkpoint.pkl", "wb") as f:
            pickle.dump(i + 1, f)

### 중단된 부분부터 다시 시작

import os
import pickle

# 저장된 결과가 있다면 이어서 로드
checkpoint_path = f"{save_dir}/checkpoint.pkl"

if os.path.exists(checkpoint_path):
    with open(checkpoint_path, "rb") as f:
        start_index = pickle.load(f)
    print(f"이전 중단 지점에서 이어서 시작: {start_index}")

    with open(f"{save_dir}/preposing.pkl", "rb") as f:
        preposing = pickle.load(f)
    with open(f"{save_dir}/inversion.pkl", "rb") as f:
        inversion = pickle.load(f)
    with open(f"{save_dir}/passive.pkl", "rb") as f:
        passive = pickle.load(f)
else:
    # 처음부터 시작
    start_index = 0
    preposing = []
    inversion = []
    passive = []
    print("처음부터 시작합니다.")

from tqdm import tqdm

for i in tqdm(range(start_index, len(df)), desc="검사 중"):
    text = df[i]

    try:
        doc = nlp(text)

        for sent in doc.sentences:
            match, noun = is_preposing(sent)
            if match:
                preposing.append([text, noun])

            match, noun = is_inversion(sent)
            if match:
                inversion.append([text, noun])

            if "by" in text.lower():
                match, noun = is_passive(sent)
                if match:
                    passive.append([text, noun])

    except Exception as e:
        print(f"{i}번째 문장에서 오류 발생: {e}")
        continue

    # 주기적으로 중간 저장
    if i % 100 == 0:
        with open(f"{save_dir}/preposing.pkl", "wb") as f:
            pickle.dump(preposing, f)
        with open(f"{save_dir}/inversion.pkl", "wb") as f:
            pickle.dump(inversion, f)
        with open(f"{save_dir}/passive.pkl", "wb") as f:
            pickle.dump(passive, f)
        with open(f"{save_dir}/checkpoint.pkl", "wb") as f:
            pickle.dump(i + 1, f)

print(len(preposing))
print(len(passive))
print(len(inversion))

import csv

# Preposing 저장
with open("preposing8.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(preposing)

# Passive 저장
with open("passive8.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(passive)

# Inversion 저장
with open("inversion8.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(inversion)

